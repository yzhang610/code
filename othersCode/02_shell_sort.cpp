//希尔排序 
//基本思想：先将整个带排序元素序列分割成若干子序列（由相隔某个“增量”的元素
//          的元素组成的）分别进行直接插入排序，然后依次缩减增量再进行排序，
//          待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次
//          直接插入排序。因为直接插入排序在元素基本有序的情况下（接近最好情
//          况），效率是很高的，因此希尔排序在时间效率上比前两种方法较好。
//算法步骤：
//1、定义增量数列
//2、根据增量数值对数据进行分块
//3、比较a[i]和a[i+gap]的大小，并排序
//4、重复步骤3，直到完成增量数值为gap从i = gap到a.length的排序
//5、重复步骤3,4，直到完成所有增量数值的排序，当最后一步数值为1，即为标准的插入排序。 
#include <stdio.h>
void shell_sort(int *a, int n)
{
	int i, j, k, t;
	k = n / 2;
	while (k > 0)
	{
		for (i = k; i < n; i++)
		{
			t = a[i];
			j = i - k;
			while (j >= 0 && t < a[j])
			{
				a[j + k] = a[j];
				j = j - k;
			}
			a[j + k] = t;
		}
		k /= 2;
	}
}
int main()
{
	int a[] = {8, 10, 3, 5, 7, 4, 6, 1, 9, 2};
	int N;
	N = sizeof(a) / sizeof(a[0]);
	shell_sort(a, N);
	for (int k = 0; k < N; k++)
		printf("a[%d] = %d\n", k, a[k]);
	return 0;
 } 
